use "C:\\Users\\sahar\\Desktop\\Code\\Ex5\\Ex5.sml";
Control.Print.printDepth := 100;
Control.Print.printLength := 240;
print("start\n");
print("tests for ex1\n");
val (["x","y"], [1,2]) = unzip (zip (["x","y"],[1,2]));
val (["x","y"], [1,2]) = unzip (build4 ("x",1,"y",2));
val (["a","b","c","d"],[[1,2],[1,2,3],[3,4,5]]) = unzip (zip (["a","b","c","d"],[[1,2],[1,2,3],[3,4,5]]));
val ([],[]) = unzip (zip ([],[]));
val ([1],[]) = unzip (zip ([1],[]));
val b = unzip (zip ([],[1])) handle Empty => (["Empty-Good"],[1]) | _ => (["Unknown-Bad"],[1]);
print("tests for Ex 2\n");
print("inbseq\n");
fun forward_n (0) (bseq) = bseq
|	  forward_n (n) (bCons(x,xf)) = forward_n (n-1) (xf(Forward));
fun back_n (0) (bseq) = bseq
|		back_n (n) (bCons(x,xf)) =back_n (n-1) (xf(Back));
val val1 = intbseq 3;
bForward val1;
bForward it;
bBack it;
bHead(forward_n 5 val1);
bHead(back_n 8 val1);
bHead(forward_n 100 (back_n 100 val1));

intbseq 2;
bForward(it);
bForward(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
print("bmap\n");
bmap (fn x => x*x) (intbseq 2);
bForward(it);
bForward(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);

bmap (fn x => if x>0 then str(chr(x)) else "non-pos") (intbseq 1);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);

bmap (fn x => if x<5 then 5 else x) (intbseq 1);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
print("bfilter\n");
bfilter (fn x => x mod 2 = 0) Back (intbseq 2);
bForward(it);
bForward(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bfilter (fn x => x mod 2 = 0) Back (intbseq 1);
bfilter (fn x => x mod 2 = 0) Forward (intbseq 1);

bfilter (fn x => x>5) Back (intbseq 1) handle Overflow => bCons(1111111,fn d =>bNil);
fun make_chr_seq x = bCons(x, fn Forward => make_chr_seq (chr(ord(x)+1)) | Back => make_chr_seq (chr(ord(x)-1)));
bfilter (fn x => (ord(x)) mod 3 = 0) Forward (make_chr_seq #"A");
bfilter (fn x => (ord(x)) mod 3 = 0) Back (make_chr_seq #"A");
print("seq2bseq\n");
fun from(x) = Cons(x, fn()=>from(x+1));
fun downfrom(x) = Cons(x, fn()=>downfrom(x-1));

seq2bseq (downfrom ~1) (from 0);
bForward(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bBack(it);
bForward(it);
bBack(it);
bForward(it);

fun mk_chr_sq x = Cons(x, fn () => mk_chr_sq (chr(ord(x)+1)));
fun mk_chr_sq2 x = Cons(x,fn () => mk_chr_sq2 (chr(ord(x)-1)));

seq2bseq (mk_chr_sq #"B") (mk_chr_sq2 #"A");
bForward(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bBack(it);
bForward(it);
bBack(it);
bForward(it);

fun const x = Cons(x, fn () => (const x));
seq2bseq (const 1) (const 2);
bForward(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bBack(it);
bForward(it);
bBack(it);
bForward(it);
print("bSeqJump\n");
intbseq 0;
bSeqJump it 3;
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bSeqJump (intbseq ~1) 1;
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bForward(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
bBack(it);
